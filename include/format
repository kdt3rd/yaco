// -*- mode: C++ -*-
//
// Copyright (c) 2012 Ian Godin
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#pragma once

#include <string>
#include <iostream>
#include <sstream>
#include <tuple>
#include <stdexcept>

////////////////////////////////////////

// Holds a format (and it's parameters).
// Objects of this class are meant to be temporary: the format holder
// should be streamed or converted to a string.
// Use the format( fmt, args... ) function to create such an object (see below).
template<typename ... Args>
class format_holder
{
public:
	// No default constructor.
	format_holder( void ) = delete;

	// No copy constructor.
	format_holder( const format_holder & ) = delete;

	// Convert to a string.
	operator std::string()
	{
		std::stringstream str;
		str << *this;
		return str.str();
	}

private:
	friend format_holder<Args...> format( std::string fmt, const Args &...args );

	template<typename CharT>
	friend std::basic_ostream<CharT> &operator<<( std::basic_ostream<CharT> &out, const format_holder<Args...> &fmt );

	format_holder( std::string fmt, const Args &...args )
		: _fmt( std::move( fmt ) ), _args( std::tie( args... ) )
	{
	}

	template <typename CharT>
	void output( std::basic_ostream<CharT> &out, size_t x ) const
	{
		get_arg<CharT, 0, std::tuple_size<std::tuple<Args...>>::value>::output( out, _args, x );
	}

	const char *format_begin( void ) const { return _fmt.c_str(); }
	const char *format_end( void ) const { return _fmt.c_str() + _fmt.size(); }

	template <typename CharT, size_t I, size_t N>
	struct get_arg
	{
		typedef get_arg<CharT,I+1,N-1> base;

		template<typename Tuple>
		static void output( std::basic_ostream<CharT> &out, const Tuple &t, size_t x )
		{
			if ( x == I )
			{
				out << std::get<I>( t );
				return;
			}
			base::output( out, t, x );
		}
	};

	template <typename CharT, size_t I>
	struct get_arg<CharT,I,0>
	{
		template<typename Tuple>
		static void output( std::basic_ostream<CharT> &, const Tuple &, size_t )
		{
			throw std::runtime_error( "Invalid fmt format string or missing argument" );
		}
	};

	std::string _fmt;
	const std::tuple<Args...> _args;
};

////////////////////////////////////////

template<typename ... Args>
format_holder<Args...> format( std::string fmt, const Args &...args )
{
	return format_holder<Args...>( std::move( fmt ), args... );
}

////////////////////////////////////////

class format_specifier
{
public:
	/// Parse the format specifier given.
	format_specifier( const char *&fmt, const char *end );

	int index;
	int width;
	int base;
	int precision;
	int alignment;
	char fill;
	bool upper_case;
	bool show_plus;

	void apply( std::ostream &out );

	static bool begin( const char * &fmt, const char *end );
};

////////////////////////////////////////

template<typename CharT, typename ... Args>
std::basic_ostream<CharT> &operator<<( std::basic_ostream<CharT> &out, const format_holder<Args...> &fmt )
{
	const char *start = fmt.format_begin();
	const char *end = fmt.format_end();
	const char *prev = start;

	while ( format_specifier::begin( start, end ) )
	{
		out.write( prev, int( start - prev ) );
		std::ios::fmtflags flags( out.flags() );

		format_specifier spec( start, end );
		spec.apply( out );

		fmt.output( out, size_t(spec.index) );
		prev = start + 1;

		out.flags( flags );
	}
	out.write( prev, int( start - prev ) );

	return out;
}

////////////////////////////////////////
// Local Variables:
// mode: C++
// End:
// vim:ft=cpp:
